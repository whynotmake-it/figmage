import 'package:equatable/equatable.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'config.g.dart';

/// {@template config}
/// A configuration for the figmage forge command, typically parsed from a
/// figmage.yaml file.
///
/// The only required arguments are the Figma file ID and the package name.
/// If nothing else is configured, the command will generate a package with all
/// color, typography, string and boolean tokens.
///
/// Number variables can be used to generate spacers, paddings and borders,
/// however, these are all off by default, as all number variables would be used
/// for all types of tokens which would clutter the namespace.
///
/// If you want to generate spacers, paddings or borders, you should consider
/// configuring `GenerationSettings.from` to only generate from a specific path.
/// {@endtemplate}
@JsonSerializable(
  anyMap: true,
  checked: true,
  explicitToJson: true,
)
class Config with EquatableMixin {
  /// {@macro config}
  const Config({
    this.packageName,
    this.fileId,
    this.packageDescription = 'A design tokens package, generated by figmage',
    this.dropUnresolved = false,
    this.stylesFromLibrary = false,
    this.asPackage = true,
    this.tokenPath = 'src',
    this.colors = const GenerationSettings(),
    this.typography = const TypographyGenerationSettings(),
    this.strings = const GenerationSettings(),
    this.bools = const GenerationSettings(),
    this.numbers = const GenerationSettings(),
    this.spacers = const GenerationSettings(generate: false),
    this.paddings = const GenerationSettings(generate: false),
    this.radii = const GenerationSettings(generate: false),
    this.assets = const AssetGenerationSettings(),
  });

  /// Initializes a [Config] from a json map.
  factory Config.fromMap(Map<dynamic, dynamic> json) => _$ConfigFromJson(json);

  /// The name of the generated dart package, e.g. figmage_example.
  ///
  /// Will default to the current directory name if not provided.
  final String? packageName;

  /// figma file ID.
  final String? fileId;

  /// The description of the generated dart package.
  final String packageDescription;

  /// Determines whether to drop unresolvable values.
  ///
  /// When true, values that
  /// cannot be resolved (e.g., an alias pointing to a missing variable) are
  /// omitted, ensuring all tokens are resolvable in all modes (e.g., light and
  /// dark mode). When false, unresolved variables are included but will return
  /// null. Defaults to false.
  final bool dropUnresolved;

  /// Whether to fetch the styles that were published to the library.
  ///
  /// If false, all styles will simply be fetched from the current state of the
  /// file.
  /// Defaults to false.
  final bool stylesFromLibrary;

  /// Whether to generate the files in a standalone package.
  ///
  /// It can be useful to set this to false, if you want to use Figmage to
  /// generate files in an existing package (such as your app), so that it won't
  /// overwrite your existing pubspec.yaml file and generate a useless barrel
  /// file.
  /// In that case, you should probably also override [tokenPath].
  ///
  /// Defaults to true.
  final bool asPackage;

  /// The path to generate the tokens at, defaults to "src".
  ///
  /// This makes sense to override if you are not using the default package
  /// structure, e.g. if you want figmage to add tokens to your existing app.
  ///
  /// See also: [asPackage]
  final String tokenPath;

  /// Color generation settings, defaults to generating color tokens from
  /// all paths.
  final GenerationSettings colors;

  /// Typography generation settings, defaults to generating typography tokens
  /// from all paths and using google fonts.
  final TypographyGenerationSettings typography;

  /// String generation settings, defaults to generating string tokens from
  /// all paths.
  final GenerationSettings strings;

  /// Boolean generation settings, defaults to generating boolean tokens from
  /// all paths.
  final GenerationSettings bools;

  /// Number generation settings, defaults to not generating number tokens from
  /// all paths.
  final GenerationSettings numbers;

  /// Spacers generation settings, defaults to not generating spacers.
  final GenerationSettings spacers;

  /// Paddings generation settings, defaults to not generating paddings.
  final GenerationSettings paddings;

  /// Borders generation settings, defaults to not generating borders.
  final GenerationSettings radii;

  /// AssetGenerationSettings
  final AssetGenerationSettings assets;

  /// All generation settings.
  List<GenerationSettings> get allGenerationSettings => [
        colors,
        typography,
        strings,
        bools,
        numbers,
        spacers,
        paddings,
        radii,
      ];

  /// Whether any setting defines at least one `from` but has `generate: false`.
  ///
  /// Is used to warn the user that there might be a potential error.
  bool get suspiciousFromDefined => allGenerationSettings
      .any((element) => element.from.isNotEmpty && element.generate == false);

  /// Converts a [Config] to a map.
  Map<dynamic, dynamic> toJson() => _$ConfigToJson(this);

  @override
  List<Object?> get props => [
        fileId,
        packageName,
        packageDescription,
        dropUnresolved,
        stylesFromLibrary,
        asPackage,
        tokenPath,
        colors,
        typography,
        strings,
        bools,
        numbers,
        spacers,
        paddings,
        radii,
      ];
}

/// {@template generation_settings}
/// Settings for generating a type of token. This includes whether or not to
/// generate the token and which paths to generate from.
/// {@endtemplate}
@JsonSerializable(anyMap: true, checked: true)
class GenerationSettings with EquatableMixin {
  /// {@macro generation_settings}
  const GenerationSettings({
    this.generate = true,
    this.from = const [],
    this.implements = const [],
  });

  /// Initializes a [GenerationSettings] from a json map.
  factory GenerationSettings.fromJson(Map<dynamic, dynamic> json) =>
      _$GenerationSettingsFromJson(json);

  /// Whether or not to generate the token, defaults to true.
  final bool generate;

  /// The paths to generate from, defaults to empty which means all paths.
  final Iterable<String> from;

  /// The implements settings for this type of token.
  ///
  /// By default, generated classes don't implement any interfaces, but you can
  /// use this setting to specify a custom list of interfaces to implement.
  final Iterable<ImplementsSettings> implements;

  /// Converts a [GenerationSettings] to a map.
  Map<dynamic, dynamic> toJson() => _$GenerationSettingsToJson(this);

  @override
  List<Object?> get props => [generate, ...from, ...implements];
}

/// {@template typography_generation_settings}
/// Settings for generating typography tokens. This includes whether or not to
/// generate the token, which paths to generate from and whether or not to use
/// google fonts.
/// {@endtemplate}
@JsonSerializable(anyMap: true, checked: true)
class TypographyGenerationSettings extends GenerationSettings {
  /// {@macro typography_generation_settings}
  const TypographyGenerationSettings({
    super.generate,
    super.from,
    super.implements,
    this.useGoogleFonts = true,
  });

  /// Initializes a [TypographyGenerationSettings] from a json map.
  factory TypographyGenerationSettings.fromJson(Map<dynamic, dynamic> json) =>
      _$TypographyGenerationSettingsFromJson(json);

  /// Whether to use google fonts for obtaining the font families, defaults to
  /// true.
  final bool useGoogleFonts;

  /// Converts a [TypographyGenerationSettings] to a map.
  @override
  Map<dynamic, dynamic> toJson() => _$TypographyGenerationSettingsToJson(this);

  @override
  List<Object?> get props => [...super.props, useGoogleFonts];
}

/// {@template implements_settings}
/// Settings for implementing interfaces in the generated code.
///
/// You can specify a list of [collections] for which this setting applies,
/// as well as a list of [interfaces] to implement in the generated code.
///
/// {@endtemplate}
@JsonSerializable(anyMap: true, checked: true)
class ImplementsSettings with EquatableMixin {
  /// {@macro implements_settings}
  const ImplementsSettings({
    this.collections = const [],
    this.interfaces = const [],
  });

  /// Initializes a [ImplementsSettings] from a json map.
  factory ImplementsSettings.fromJson(Map<String, dynamic> json) =>
      _$ImplementsSettingsFromJson(json);

  /// The paths to generate from, defaults to empty.
  ///
  /// If you leave this empty, but specify [interfaces], the interfaces will
  /// apply to all collections.
  final List<String> collections;

  /// The interfaces to implement in the generated code.
  final List<InterfaceSettings> interfaces;

  /// Converts a [ImplementsSettings] to a map.
  Map<String, dynamic> toJson() => _$ImplementsSettingsToJson(this);

  @override
  List<Object?> get props => [...collections, ...interfaces];
}

/// {@template interface_settings}
/// Settings for a single interface to implement in the generated code.
///
/// This includes the name of the interface and the import directive for that
/// interface.
/// {@endtemplate}
@JsonSerializable(anyMap: true, checked: true)
class InterfaceSettings with EquatableMixin {
  /// {@macro interface_settings}
  const InterfaceSettings({
    required this.name,
    required this.import,
  });

  /// Initializes a [InterfaceSettings] from a json map.
  factory InterfaceSettings.fromJson(Map<String, dynamic> json) =>
      _$InterfaceSettingsFromJson(json);

  /// The name of the interface to implement.
  final String name;

  /// The content of the import directive for that interface.
  final String import;

  /// Converts a [ImplementsSettings] to a map.
  Map<String, dynamic> toJson() => _$InterfaceSettingsToJson(this);

  @override
  List<Object?> get props => [name, import];
}

/// {@template asset_node_settings}
/// Settings for a single asset node from Figma.
/// {@endtemplate}
@JsonSerializable(anyMap: true, checked: true)
class AssetNodeSettings with EquatableMixin {
  /// {@macro asset_node_settings}
  const AssetNodeSettings({
    required this.name,
    this.scales = const {1},
  });

  /// Factory constructor for creating a new `AssetNodeSettings` instance from a
  /// map.
  factory AssetNodeSettings.fromJson(Map<String, dynamic> json) =>
      _$AssetNodeSettingsFromJson(json);

  /// The name to use for the asset.
  final String name;

  /// The scale factors to generate for this asset.
  final Set<num> scales;

  /// Converts this `AssetNodeSettings` instance to a map.
  Map<String, dynamic> toJson() => _$AssetNodeSettingsToJson(this);

  @override
  List<Object?> get props => [name, scales];
}

/// {@template asset_generation_settings}
/// Settings for generating assets from Figma nodes.
/// {@endtemplate}
@JsonSerializable(anyMap: true, checked: true, explicitToJson: true)
class AssetGenerationSettings extends GenerationSettings {
  /// {@macro asset_generation_settings}
  const AssetGenerationSettings({
    super.generate = false,
    this.nodes = const <String, AssetNodeSettings>{},
  });

  /// Creates a [AssetGenerationSettings] from a json map.
  factory AssetGenerationSettings.fromJson(Map<String, dynamic> json) =>
      _$AssetGenerationSettingsFromJson(json);

  /// The nodes to generate assets from, keyed by node ID.
  final Map<String, AssetNodeSettings> nodes;

  /// Converts [AssetGenerationSettings] to a json map.
  @override
  Map<String, dynamic> toJson() => _$AssetGenerationSettingsToJson(this);

  @override
  List<Object?> get props => [...super.props, nodes];
}
